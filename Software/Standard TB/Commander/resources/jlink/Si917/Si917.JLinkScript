/***********************************************************************
*                    SEGGER Microcontroller GmbH                       *
*                        The Embedded Experts                          *
************************************************************************
*                                                                      *
*                  (c) SEGGER Microcontroller GmbH                     *
*                        All rights reserved                           *
*                          www.segger.com                              *
*                                                                      *
************************************************************************
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*  Licensing terms                                                     *
*                                                                      *
* The use in source and binary forms, with or without modification,    *
* is permitted for internal use only. The redistribution to any        *
* third party is prohibited.                                           *
*                                                                      *
*                                                                      *
* THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER "AS IS" AND ANY        *
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR   *
* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER BE        *
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,     *
* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,             *
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   *
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  *
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT         *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE    *
* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH     *
* DAMAGE.                                                              *
*                                                                      *
************************************************************************

-------------------------- END-OF-HEADER -----------------------------

Purpose: Implementation of the generic Cortex-M device reset (Reset strategy Type 0: Normal).
Literature:
  [1]  J-Link User Guide
  [2]  https://wiki.segger.com/J-Link_Reset_Strategies#Type_0:_Normal
*/

/*********************************************************************
*
*       Constants, fixed
*
**********************************************************************
*/
//
// Registers (ARM)
//
__constant U32 _AIRCR_ADDR         = 0xE000ED0C; // Application Interrupt and Reset Control Register
__constant U32 _DHCSR_ADDR         = 0xE000EDF0; // Debug Halting Control and Status Register
__constant U32 _DEMCR_ADDR         = 0xE000EDFC; // Debug Exception and Monitor Control Register

//
// Bits & Shifts (ARM)
//
__constant U32 _DP_CTRL_STAT_BIT_STICKYERR = (1 <<  5);

__constant U32 _DHCSR_DBGKEY               = (0xA05F << 16);
__constant U32 _DHCSR_C_DEBUGEN            = (1 <<  0);
__constant U32 _DHCSR_C_HALT               = (1 <<  1);
__constant U32 _DHCSR_S_HALT               = (1 << 17);
__constant U32 _DHCSR_S_RESET_ST           = (1 << 25);

__constant U32 _DEMCR_VC_CORERESET         = (1 <<  0);
__constant U32 _DEMCR_TRCENA               = (1 << 24);

__constant U32 _AIRCR_VECTKEY              = (0x05FA << 16);
__constant U32 _AIRCR_SYSRESETREQ          = (1 <<  2);

//
// SiWx91x Registers
//
//__constant U32 _QSPI_BASE_ADDR            = 0x12000000;
//__constant U32 _QSPI_CTRL_ADDR            = _QSPI_BASE_ADDR + 0x2C;
__constant U32 _QSPI_CLK_ADDR             = 0x12040000;
__constant U32 _QSPI_CLK_VALUE            = 0x00000101;
__constant U32 _QSPI_MODE_ADDR            = 0x12040004;
__constant U32 _QSPI_MODE_MASK            = 0x00010C00;


/*********************************************************************
*
*       Constants, configurable
*
**********************************************************************
*/

__constant U32 _DEF_BUSY_TIMEOUT = 20000;

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*********************************************************************
*
*       _DAPClrStickyErr
*
*  Function description
*    Clears the DAP sticky error flags.
*/
static void _DAPClrStickyErr(void) {
  U32 v;
  //
  // The DP is slightly different for JTAG and SWD regarding clearing sticky error bits.
  //
  if (JLINK_ActiveTIF == JLINK_TIF_SWD) {
    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_ABORT, 0x1E);
  } else {
    v  = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT);
    v |= _DP_CTRL_STAT_BIT_STICKYERR;
    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, v);
  }  
}

/*********************************************************************
*
*       Global functions
*
**********************************************************************
*/

/*********************************************************************
*
*       ResetTarget()
*
*  Function description
*    Replaces reset strategies of DLL. No matter what reset type is selected in the DLL, if this function is present, it will be called instead of the DLL internal reset.
*
*  Notes
*    (1) DLL expects target CPU to be halted / in debug mode, when leaving this function
*    (2) May use MEM_ API functions
*/
int ResetTarget(void) {
  int t;
  int r;
  U32 v;
  U32 u;
  
  JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, 0xF0000000);

  JLINK_SYS_Report("Reset: Halt core after reset via DEMCR.VC_CORERESET.");
  JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN)); // Halt the CPU
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (_DEMCR_VC_CORERESET | _DEMCR_TRCENA));              // Set vector catch on reset (to halt the CPU immediately after reset)
  _DAPClrStickyErr();                                                                  // Make sure that no sticky error bits are set on the DP
  JLINK_SYS_Report("Reset: Reset device via AIRCR.SYSRESETREQ. Extended timeout.");
  JLINK_MEM_WriteU32(_AIRCR_ADDR, (_AIRCR_VECTKEY | _AIRCR_SYSRESETREQ));              // Issue reset request via SFR
  JLINK_SYS_Sleep(50);                                                                 // The spec. does not guarantee that the reset takes place immediately, so we give the target some time.
  //
  // Wait until S_RESET_ST is set
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: CPU may not have been reset (DHCSR.S_RESET_ST never gets set).");
      return -1;
    }
  } while (1);

  JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN)); // Halt the CPU
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (_DEMCR_VC_CORERESET | _DEMCR_TRCENA));              // Set vector catch on reset (to halt the CPU immediately after reset)

  //
  // Wait until S_RESET_ST is cleared
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v == 0) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.");
      break;
    }
  } while (1);
  //
  // Make sure we clear the vector catch we have set before
  //
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (0x0 | _DEMCR_TRCENA));

  //
  // Wait for the QSPI controller to be configured
  //
  JLINK_SYS_Report("Reset: Wait for the code areas to be accessible.");
  
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {

    JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN));  // Halt the CPU
    v = JLINK_MEM_ReadU32(_QSPI_CLK_ADDR);
    u = JLINK_MEM_ReadU32(_QSPI_MODE_ADDR);

    //JLINK_SYS_Report1("Reset: QSPI CLK: ", v);
    //JLINK_SYS_Report1("Reset: QSPI MODE: ", u);

    // Check for QSPI configuration
    if ((v == _QSPI_CLK_VALUE) && ((u & _QSPI_MODE_MASK) == _QSPI_MODE_MASK)) {
      JLINK_SYS_Report("Reset: QSPI configured.");
      break;
    }

    // Check for timeout
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: QSPI never gets configured according to the expected values.");
      break;
    }

    JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_DEBUGEN));                  // Release the core

  } while (1);
  
  
  return 0;
}

/*************************** end of file ****************************/
